# ─── GIT PROMPT CONFIGURATION ─────────────────────────────────────────────────

# This file provides Git repository status information for ZSH prompt customization
# It uses native ZSH commands with intelligent caching for maximum performance

# ─── THEME VARIABLES ──────────────────────────────────────────────────────────

# Apparence du prompt Git
ZSH_THEME_GIT_PROMPT_PREFIX="%F{%(#.red.blue)}(%F{1;31}\uf418%f"   # Le préfixe du prompt : couleur rouge si root, bleue si non-root
ZSH_THEME_GIT_PROMPT_SUFFIX="%F{%(#.red.blue)})\uf068"               # Le suffixe du prompt : couleur rouge si root, bleue si non-root
ZSH_THEME_GIT_PROMPT_SEPARATOR=" | "                              # Séparateur entre le préfixe et la branche
ZSH_THEME_GIT_PROMPT_BRANCH="%F{255}"                           # Branche Git : couleur blanche (code 255)
ZSH_THEME_GIT_PROMPT_STAGED="%F{91}%{\uf055%G%}"                     # Changements mis en scène : couleur rouge clair (code 91) avec un point vert
ZSH_THEME_GIT_PROMPT_CONFLICTS="%F{91}%{\ueab8%G%}"                  # Conflits de fusion : couleur rouge clair (code 91) avec un "X" vert
ZSH_THEME_GIT_PROMPT_CHANGED="%F{94}%{\uea60%G%}"                    # Fichiers modifiés : couleur bleu clair (code 94) avec un signe "+" vert
ZSH_THEME_GIT_PROMPT_BEHIND="%{\uefc3%G%}"                           # Branche en retard : un signe "<" vert
ZSH_THEME_GIT_PROMPT_AHEAD="%{\uedfb%G%}"                            # Branche en avance : un signe ">" vert
ZSH_THEME_GIT_PROMPT_UNTRACKED="%F{96}%{ … %G%}"                  # Fichiers non suivis : couleur cyan clair (code 96) avec des points de suspension verts
ZSH_THEME_GIT_PROMPT_STASHED="%F{94}%{\uf487%G%}"                  # Changements mis en cache (stash) : couleur bleu clair (code 94) avec des crochets vides verts
ZSH_THEME_GIT_PROMPT_CLEAN="%F{92}%{\uf00c%G%}"                      # Etat propre (pas de modifications) : couleur vert clair (code 92) avec un "√" vert

# ─── CACHE CONFIGURATION ──────────────────────────────────────────────────────

# Intelligent caching system for Git status
typeset -g __GIT_CACHE_TIMEOUT=5        # Cache timeout in seconds
typeset -g __GIT_LAST_UPDATE=0          # Last update timestamp
typeset -g __GIT_CACHE_DIR="${HOME}/.zsh/git_cache"
typeset -g __GIT_CURRENT_REPO=""        # Current repository path

# ─── CACHE MANAGEMENT ─────────────────────────────────────────────────────────

# Initialize cache directory
_init_git_cache() {
    [[ ! -d "$__GIT_CACHE_DIR" ]] && mkdir -p "$__GIT_CACHE_DIR"
}

# Get cache file path for current repository
_get_cache_file() {
    local repo_path=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -n "$repo_path" ]]; then
        echo "${__GIT_CACHE_DIR}/$(echo "$repo_path" | tr '/' '_' | tr ' ' '_')"
    fi
}

# Check if cache is valid
_is_cache_valid() {
    local cache_file="$1"
    local current_time=$(date +%s)
    
    if [[ -f "$cache_file" ]]; then
        local cache_time=$(stat -c %Y "$cache_file" 2>/dev/null || echo "0")
        if (( current_time - cache_time < __GIT_CACHE_TIMEOUT )); then
            return 0  # Cache is valid
        fi
    fi
    return 1  # Cache is invalid or missing
}

# Save Git status to cache
_save_git_cache() {
    local cache_file="$1"
    local git_data="$2"
    
    if [[ -n "$cache_file" ]] && [[ -n "$git_data" ]]; then
        echo "$git_data" > "$cache_file" 2>/dev/null
    fi
}

# Load Git status from cache
_load_git_cache() {
    local cache_file="$1"
    
    if [[ -f "$cache_file" ]]; then
        cat "$cache_file" 2>/dev/null
    fi
}

# ─── GIT STATUS FUNCTIONS ─────────────────────────────────────────────────────

# Enhanced Git status with caching
function update_current_git_vars() {
    
    # Initialize cache if needed
    _init_git_cache
    
    # Get cache file for current repository
    local cache_file="$(_get_cache_file)"
    local current_repo=$(git rev-parse --show-toplevel 2>/dev/null)
    
    # Check if we're in a Git repository
    if [[ -z "$current_repo" ]]; then
        unset __CURRENT_GIT_STATUS GIT_BRANCH GIT_AHEAD GIT_BEHIND GIT_STAGED GIT_CONFLICTS GIT_CHANGED GIT_UNTRACKED GIT_STASHED GIT_CLEAN
        return 1
    fi
    
    # Check if repository changed
    if [[ "$__GIT_CURRENT_REPO" != "$current_repo" ]]; then
        __GIT_CURRENT_REPO="$current_repo"
        unset __CURRENT_GIT_STATUS
    fi
    
    # Check if cache is valid and load from cache
    if _is_cache_valid "$cache_file"; then
        local cached_data="$(_load_git_cache "$cache_file")"
        
        # Parse cached data
        local parts=(${(s:|:)cached_data})
        
        if [[ ${#parts[@]} -eq 9 ]]; then
            export GIT_BRANCH="${parts[1]}"
            export GIT_AHEAD="${parts[2]}"
            export GIT_BEHIND="${parts[3]}"
            export GIT_STAGED="${parts[4]}"
            export GIT_CONFLICTS="${parts[5]}"
            export GIT_CHANGED="${parts[6]}"
            export GIT_UNTRACKED="${parts[7]}"
            export GIT_STASHED="${parts[8]}"
            export GIT_CLEAN="${parts[9]}"
            
            # Set status array for compatibility
            typeset -g __CURRENT_GIT_STATUS=("${parts[@]}")
            return 0
        fi
    fi
    
    # Cache miss or invalid, get fresh data
    local git_data="$(_get_git_status_data)"
    if [[ -n "$git_data" ]]; then
        _save_git_cache "$cache_file" "$git_data"
        _parse_git_data "$git_data"
    fi
}

# Get fresh Git status data
function _get_git_status_data() {
    # Get current branch
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [[ -z "$branch" ]] || [[ "$branch" == "HEAD" ]]; then
        return 1
    fi
    
    # Get ahead/behind counts
    local ahead_behind=$(git rev-list --count --left-right @{upstream}...HEAD 2>/dev/null)
    local behind=0 ahead=0
    if [[ -n "$ahead_behind" ]]; then
        read behind ahead <<< "$ahead_behind"
    fi
    
    # Get all status counts in parallel for better performance
    local staged=$(git diff --cached --name-only 2>/dev/null | wc -l)
    local conflicts=$(git diff --name-only --diff-filter=U 2>/dev/null | wc -l)
    local changed=$(git diff --name-only 2>/dev/null | wc -l)
    local untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l)
    local stashed=$(git stash list 2>/dev/null | wc -l)
    
    # Check if repository is clean
    local clean=0
    if (( staged == 0 && conflicts == 0 && changed == 0 && untracked == 0 )); then
        clean=1
    fi
    
    # Return formatted data
    echo "$branch|$ahead|$behind|$staged|$conflicts|$changed|$untracked|$stashed|$clean"
}

# Parse Git data and set variables
function _parse_git_data() {
    local git_data="$1"
    local IFS='|'
    local parts=($git_data)
    
    if [[ ${#parts[@]} -eq 9 ]]; then
        typeset -g GIT_BRANCH="${parts[1]}"
        typeset -g GIT_AHEAD="${parts[2]}"
        typeset -g GIT_BEHIND="${parts[3]}"
        typeset -g GIT_STAGED="${parts[4]}"
        typeset -g GIT_CONFLICTS="${parts[5]}"
        typeset -g GIT_CHANGED="${parts[6]}"
        typeset -g GIT_UNTRACKED="${parts[7]}"
        typeset -g GIT_STASHED="${parts[8]}"
        typeset -g GIT_CLEAN="${parts[9]}"
        
        # Set status array for compatibility
        typeset -g __CURRENT_GIT_STATUS=("${parts[@]}")
    fi
}

# ─── PROMPT FORMATTING ───────────────────────────────────────────────────────

# Git prompt formatting function with caching
function git_super_status() {
    # Update Git variables (uses cache if available)
    update_current_git_vars
    
    # Check if we have valid Git status
    if [[ -n "$GIT_BRANCH" ]]; then
        local STATUS=""
        
        # Branch name
        STATUS="$ZSH_THEME_GIT_PROMPT_PREFIX$ZSH_THEME_GIT_PROMPT_BRANCH$GIT_BRANCH%{${reset_color}%}"
        
        # Behind indicator
        if [[ "$GIT_BEHIND" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_BEHIND$GIT_BEHIND%{${reset_color}%}"
        fi
        
        # Ahead indicator
        if [[ "$GIT_AHEAD" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_AHEAD$GIT_AHEAD%{${reset_color}%}"
        fi
        
        # Staged changes
        if [[ "$GIT_STAGED" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_STAGED$GIT_STAGED%{${reset_color}%}"
        fi
        
        # Conflicts
        if [[ "$GIT_CONFLICTS" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_CONFLICTS$GIT_CONFLICTS%{${reset_color}%}"
        fi
        
        # Modified files
        if [[ "$GIT_CHANGED" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_CHANGED$GIT_CHANGED%{${reset_color}%}"
        fi
        
        # Untracked files
        if [[ "$GIT_UNTRACKED" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_UNTRACKED$GIT_UNTRACKED%{${reset_color}%}"
        fi
        
        # Stashed changes
        if [[ "$GIT_STASHED" -ne "0" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_STASHED$GIT_STASHED%{${reset_color}%}"
        fi
        
        # Clean repository
        if [[ "$GIT_CLEAN" -eq "1" ]]; then
            STATUS+="$ZSH_THEME_GIT_PROMPT_CLEAN"
        fi
        
        STATUS+="$ZSH_THEME_GIT_PROMPT_SUFFIX"
        echo "$STATUS"
    fi
}

# ─── HOOKS ───────────────────────────────────────────────────────────────────

# Add ZSH hooks for automatic updates
autoload -U add-zsh-hook

# Update Git status when changing directories
add-zsh-hook chpwd update_current_git_vars

# Update Git status before each prompt
add-zsh-hook precmd update_current_git_vars

# Update Git status when executing Git commands
add-zsh-hook preexec _git_command_hook

# Hook for Git commands
function _git_command_hook() {
    case "$2" in
        git*|hub*|gh*|stg*)
            # Invalidate cache for Git commands
            local cache_file="$(_get_cache_file)"
            [[ -f "$cache_file" ]] && rm -f "$cache_file"
            ;;
    esac
}

